# Grid, Direction
# Direction.NORTH,SOUTH,EAST,WEST,NE,SE,NW,SW
# g = Grid([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# g.width, g.height, (y, x) in g (coords), g[(y, x)], g[(y, x)] = 5
# for item in g => iterate over items in row major order
# g.row_major(_with_index)() => iterate over items in row major order
# g.column_major(_with_index)() => iterate over items in column major order
# g.apply(func) => call func with each item
# g.map(func) => return new Grid with results of func
# g.ray_from((y, x), direction), yields items from a starting point in a direction
# g.around(_with_index) => What it sounds like

# Graph
# g = Graph()
# g.add_edge(from, to, weight=something)
# g.dijkstra(start) => Dijkstra (has `distance_to`, and `path_to` methods)

# ShuntingYard
# Expression parser with configurable precedence for operations so you can throw out (B)EDMAS (no support for brackets)

from aoc_utils import * # type: ignore
from aocd import get_data
import heapq

data = get_data(year=2023, day=17, block=True)
# data = """2413432311323
# 3215453535623
# 3255245654254
# 3446585845452
# 4546657867536
# 1438598798454
# 4457876987766
# 3637877979653
# 4654967986887
# 4564679986453
# 1224686865563
# 2546548887735
# 4322674655533"""
grid = Grid([[int(c) for c in l] for l in data.splitlines()])

# h = horizontal streak
# v = vertical streak
#        y  x  h  v
start = (0, 0, 0, 0)
inf = float('inf')
dist = { start: 0 }
prev = { }
pq = [(0, start)]
history = set()

def edges_with_weight(p):
    y, x, h, v = p
    prev_y, prev_x, _, _ = previous = prev[p] if p in prev else (-1, -1, -1, -1)

    for (py, px), cost in grid.around_with_index((y, x), corners=False):
        vert = py == y
        hori = px == x
        if p not in prev or (py, px) != (prev_y, prev_x):
            if vert:
                ph = 0
                pv = v + 1
            elif hori:
                pv = 0
                ph = h + 1
            else:
                assert False

            if ph >= 4 or pv >= 4:
                continue

            np = (py, px, ph, pv)
            yield (cost, np)

# Dijkstra doesn't work for this problem
# The issue is that two points may be connected in one path
# but not in another due to the consecutive rule
# This causes Dijkstra to discard paths that end up being correct too early

# Example
#          343231
# start -> 545353 <- target
#
# Correct
#  34****
#  ***35*
#    ^ took a worse tile here (5 over a 4) so that it would have enough distance to take the better path on top
#
# Incorrect (generated by my dijkstra code)
#
# 3****1
# **53**
#     ^ forced to take a 5 over a 1 because of consecutive rule
#
# the above path is culled too early because they both arrive at the same point (second 3 of top row), the correct path through a 5, incorrect through a 4

# Eureka!
# This is a 3d space in disguise, the "# consecutive in the same direction" being the third coordinate


while pq:
    _, u = heapq.heappop(pq)
    if u in history:
        continue
    history.add(u)
    for cost, v in edges_with_weight(u):
        if v in history:
            continue

        alt = dist[u] + cost
        if alt < dist.get(v, inf):
            dist[v] = alt
            prev[v] = u
            heapq.heappush(pq, (alt, v))

from functools import cache

class DijkstraResult:
    def __init__(self, start, distances, predecessors):
        self.start = start
        self.distances = distances
        self.predecessors = predecessors

    def distance_to(self, target) -> int:
        return self.distances[target]

    @cache
    def path_to(self, target):
        path = []
        node = target
        while node is not self.start:
            path.append(node)
            node = self.predecessors[node]
        path.append(node)
        path.reverse()
        return path

d = DijkstraResult(start, dist, prev)
md = float('inf')
for conseq in range(4):
    try:
        md = min(md, d.distance_to((grid.height-1, grid.width-1, conseq, 0)))
    except KeyError:
        pass
    try:
        md = min(md, d.distance_to((grid.height-1, grid.width-1, 0, conseq)))
    except KeyError:
        pass

print(md)

# print(d.path_to((grid.height-1, grid.width-1, 1)))
# path = {(y, x) for (y, x, _) in d.path_to((grid.height-1, grid.width-1, 1))}
# for y in range(grid.height):
#     for x in range(grid.height):
#         if (y, x) in path:
#             print(end='#')
#         else:
#             print(grid[y, x], end='')
#     print()
